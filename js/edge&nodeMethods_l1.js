/***************************************************
 * semdiag: draw SEM path diagram interactively    *
 * Authors: Yujiao Mai, Zhiyong Zhang, Ke-Hai Yuan *
 * Copyright 2015-2015, psychstat.org              *
 * Licensed under the MIT License (MIT)            *
 * Current software version 1.0                    *
 * Support email for questions zzhang4@nd.edu      *
 *                             ymai@nd.edu         * 
 ***************************************************/

/* the file 'edge&nodeMethods_l1.js':  functions are the operations of the nodes and edges at the lower layer */
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//function: to generate a new node
function NewNode(){
	var newnode;
	var t_id='';
	var t_type='ellipse';
	var t_x=default_RADIUSH;
	var t_y=default_RADIUSV;
	var t_rx=default_RADIUSH;
	var t_ry=default_RADIUSV;
	var t_color=defaultCOLOR;
	var t_dotted='none';
	var t_title='';
	var t_fontsize=defaultFONTSIZE;
	var t_strokewidth=default_strokeWIDTH;
	var t_selected=false;
	newnode={
		id:t_id,
		type:t_type,
		x:Number(t_x),
		y:Number(t_y),
		rx:Number(t_rx),
		ry:Number(t_ry),
		color:t_color,
		strokedotted:Number(t_dotted),
		title:t_title,
		fontsize:Number(t_fontsize),
		strokewidth:Number(t_strokewidth),
		selected:t_selected
	};
	return newnode;
}

//function: to generate a new edge
function NewEdge(){
	var newedg;
	var t_id='';
	var t_type='';
	var t_power=2;
	var t_node1='';
	var t_node2='';
	var t_handlePx=-1;
	var t_handelPy=-1;
	var t_color=defaultCOLOR;
	var t_dotted='none';
	var t_strokewidth=default_strokeWIDTH;
	var t_label='';
	var t_labelPx=-1;
	var t_labelPy=-1;
	var t_labelFsize =defaultFONTSIZE;
	var t_labelInitial = true;
	var t_curve_LR=-1;
	var t_handleInitial=true;
	var t_IsAutoGenerated=false;
	var t_selected=false;
	newedge={
		id:t_id,
		power:t_power,
		type:t_type,
		startid:t_node1,
		endid:t_node2,
		handlePx:t_handlePx,
		handlePy:t_handelPy,
		color:t_color,
		dotted:t_dotted,
		strokewidth:t_strokewidth,
		label:t_label,
		labelPx:t_labelPx,
		labelPy:t_labelPy,
		labelFsize:t_labelFsize,
		labelInitial:t_labelInitial,
		curve_LR:t_curve_LR,
		handleInitial:t_handleInitial,
		IsAutoGenerated: t_IsAutoGenerated,
		selected:t_selected
  };
  return newedge;
}

//function: to generate a new note
function NewNote(){
	var newnote;
	var t_x=default_RADIUSH;
	var t_y=default_RADIUSV;
	var t_color=defaultCOLOR;
	var t_text='';
	var t_fontsize=defaultFONTSIZE;
	var t_selected=false;
	newnote={
		id:'',
		x:Number(t_x),
		y:Number(t_y),
		color:t_color,
		text:t_text,
		fontsize:Number(t_fontsize),
		selected:t_selected
	};
	return newnote;
}

//function： to find the index in the array _nodes with a given node id
function matchnodeindex(_nodes, _nodeid) {
	var temp=-1;
	for (var i=0; i < _nodes.length; i++){
		if (_nodes[i].id ===_nodeid) {
			temp = i;
			return temp;
		}		
	}
	return temp;	//if not found return -1
}

//function： to find the index in the array _edges with a given edge id
function matchedgeindex(_edges, _edgeid) {
	var temp=-1;
	for (var i=0; i < _edges.length; i++){
		if (_edges[i].id ===_edgeid) {
			temp = i;
			return temp;
		}		
	}
	return temp;	//-1
}

//function： to find the index in the array _notes with a given note id
function matchnoteindex(_notes, _noteid) {
	var temp=-1;
	for (var i=0; i < _notes.length; i++){
		if (_notes[i].id ===_noteid) {
			temp = i;
			return temp;
		}		
	}
	return temp;	//-1
}

//function： to generate the resize control points for the given nodes
function generate_resize_cPs(_nodes){
	var resize_cPs = [];
	for (var i = 0; i < _nodes.length; i++){
		var _node = _nodes[i];
		var rx = _node.rx;
		var ry = _node.ry;
		switch (_node.type){
			case "ellipse":
				{
					var leftP = {x: _node.x -rx - 2*cPr, y: _node.y };
					var rightP = {x: _node.x + rx + 2*cPr , y: _node.y};
					var topP = {x: _node.x , y: _node.y - ry - 2*cPr };
					var bottomP = {x: _node.x, y: _node.y + ry + 2*cPr };
					var cP1 = {
							nodeid: _node.id,
							pos:leftP,
							type:"left"							
						};
					var cP2 = {
							nodeid: _node.id,
							pos:rightP,
							type:"right"							
						};
					var cP3 = {
							nodeid: _node.id,
							pos:topP,
							type:"top"							
						};
					var cP4 = {
							nodeid: _node.id,
							pos:bottomP,
							type:"bottom"							
						};
					resize_cPs.push(cP1);
					resize_cPs.push(cP2);
					resize_cPs.push(cP3);
					resize_cPs.push(cP4);
				}
				break;
			case "rect":
				{
					var leftP = {x: _node.x -rx - 2*cPr, y: _node.y };
					var rightP = {x: _node.x + rx + 2*cPr , y: _node.y};
					var topP = {x: _node.x , y: _node.y - ry - 2*cPr };
					var bottomP = {x: _node.x, y: _node.y + ry + 2*cPr };
					var cP1 = {
							nodeid: _node.id,
							pos:leftP,
							type:"left"							
						};
					var cP2 = {
							nodeid: _node.id,
							pos:rightP,
							type:"right"							
						};
					var cP3 = {
							nodeid: _node.id,
							pos:topP,
							type:"top"							
						};
					var cP4 = {
							nodeid: _node.id,
							pos:bottomP,
							type:"bottom"							
						};
					resize_cPs.push(cP1);
					resize_cPs.push(cP2);
					resize_cPs.push(cP3);
					resize_cPs.push(cP4);
				}
				break;
			case "triangle":
				{
					var topP = {x: _node.x, y: _node.y - ry - 2*cPr };
					var left_bottom_P = {x: _node.x - rx * Math.sqrt(3)/2 - 2*cPr, y: _node.y + ry /2 + 2*cPr};
					var right_bottom_P = {x: _node.x + rx * Math.sqrt(3)/2 + 2*cPr, y: _node.y + ry /2 + 2*cPr };
					var cP1 = {
							nodeid: _node.id,
							pos:topP,
							type:"top"							
						};
					var cP2 = {
							nodeid: _node.id,
							pos:left_bottom_P,
							type:"left_bottom"							
						};
					var cP3 = {
							nodeid: _node.id,
							pos:right_bottom_P,
							type:"right_bottom"							
						};
				
					resize_cPs.push(cP1);
					resize_cPs.push(cP2);
					resize_cPs.push(cP3);				
				}
				break;
			default:;
		}
	}
	return resize_cPs;
}

//function: to generate the path/edge label for the given startnode and endnode 
function generate_label(_startnode, _endnode, _ArrowType, _bcurvePower){
	var _startnodeType=_startnode.type;
	var _endnodeType = _endnode.type;
	var _startnodeTitle = _startnode.title;
	var _endnodeTitle = _endnode.title;
	var label="a_"+_startnodeTitle+"_"+_endnodeTitle;
	switch(_ArrowType){
		case "bi": 
			if (_bcurvePower===2){
				label ="r_"+_startnodeTitle+"_"+_endnodeTitle;
			} else if (_bcurvePower===3){
				label ="e_"+_startnodeTitle;
			}
			break;
		case "uni":
			if (_startnodeType ==="triangle" ){
				label = "u_"+ _endnodeTitle;			
			} else if (_startnodeType==="ellipse" & _endnodeType === "rect"){
				label ="l_"+_startnodeTitle+"_"+_endnodeTitle;
			} else {
				label ="b_"+_startnodeTitle+"_"+_endnodeTitle;
			}
			break;
		default:label="a_"+_startnodeTitle+"_"+_endnodeTitle;
	}
	return label;
}

//function: to calculate the default position of the label 
function cal_labelP(_handleP, _node1P, _node2P, _power, delta_x, delta_y){ 
	var templabelP = {x:_handleP.x+15, y: _handleP.y-15};
	switch(_power){
		case 2:
			if(delta_x !== null & delta_y !== null){
				templabelP = {x:_handleP.x+delta_x, y: _handleP.y+delta_y};
			} else {
				templabelP = {x:_handleP.x+15,y: _handleP.y-15};
			}
		break;
		case 3: 
		{
			if (_handleP.x < _node1P.x) {
				templabelP.x = _handleP.x - 20;
			} else if (_handleP.x > _node1P.x){
				templabelP.x = _handleP.x + 15;
			} else {
				templabelP.x = _handleP.x;
			}
			if (_handleP.y < _node1P.y) {
				templabelP.y = _handleP.y - 15;
			} else if (_handleP.y > _node1P.y){
				templabelP.y = _handleP.y + 20;
			} else {
				templabelP.y = _handleP.y;
			}			
		}
		break;
		default:;
	}//end of switch
	return templabelP;
}	

//function：  to generate a bcurve of power 2
function generate_bcurve2p(_nodes,_startid, _endid,  _arrowType){ 
		var tempbcurve2p = null;
		var _i=matchnodeindex(_nodes,_startid);
		var _j=matchnodeindex(_nodes,_endid);	
		var _startP = {x: _nodes[_i].x, y:_nodes[_i].y};
		var _endP= {x: _nodes[_j].x, y:_nodes[_j].y};
		var _handleP = { x:(_startP.x + _endP.x)/2,  y:(_startP.y + _endP.y)/2	};
		var tempcP = {x: _handleP.x * 2 - (_startP.x + _endP.x) / 2, y: _handleP.y * 2 - (_startP.y + _endP.y) / 2};
		var templine = "M"+ _startP.x + " " + _startP.y + " " + "Q" + tempcP.x+" " + tempcP.y + " " + _endP.x+" " + _endP.y ;
		var templabel = generate_label(_nodes[_i], _nodes[_j], _arrowType, 2);
		var templabelP = cal_labelP(_handleP, _startP, _endP, 2, null, null);
		var tempbcurve2p={
			id:"edge"+String(Edgecurrent_IdNUM),
			power:2,
			startid: _startid,
			endid: _endid,
			handleP:_handleP,
			cP:tempcP,
			line: templine,			
			type: _arrowType,
			dotted: 0, 
			color:defaultCOLOR,
			strokewidth:default_strokeWIDTH,
			label: templabel,
			labelP: templabelP,
			labelFsize: defaultFONTSIZE,
			labelInitial:true,
			labelshow: true,
			handlePshow: false,
			handleInitial:true, 
			IsAutoGenerated: false,
			curve_LR:default_selfcurve_LR,
			selected:false
		};
		return tempbcurve2p;
}

//function： to generate a bcurve of power 3
function generate_bcurve3p(_nodes,_nodeid, _arrowType){ 			
	var tempbcurve3p = null;
	var _theta = selfpathTHETA_default;
	var _Angle = selfpathANGLE_default;
	var i =matchnodeindex(_nodes,_nodeid);
	var targetnode=_nodes[i];
	var selfcurve_LR=default_selfcurve_LR;
	var current_r=0;
	var newr=0;
	switch(targetnode.type){
		case "ellipse": {
			var aa=targetnode.rx;
			var bb=targetnode.ry;
			current_r = aa * bb / Math.sqrt( (bb * Math.cos(_theta) ) * (bb * Math.cos(_theta) ) +  (aa * Math.sin(_theta)) *(aa * Math.sin(_theta)) )
		}
			break;
		case "rect":{  
			var current_r = 0;
			var rectalpha = Math.atan(targetnode.ry / targetnode.rx); 
			if (_theta >= rectalpha & _theta <= Math.PI - rectalpha){
				current_r = Math.abs( targetnode.ry / Math.sin(_theta) );
			} else if ( (_theta >= 2* Math.PI - rectalpha & _theta <= 2* Math.PI) || (_theta >= 0 & _theta<= rectalpha)){
				current_r = Math.abs( targetnode.rx/ Math.cos(_theta) );
			} else if (_theta >= Math.PI+ rectalpha & _theta <= 2* Math.PI - rectalpha){
				current_r = Math.abs( targetnode.ry / Math.sin(_theta) );
			} else if (_theta >= Math.PI- rectalpha & _theta <= Math.PI + rectalpha){
				current_r = Math.abs( targetnode.rx/ Math.cos(_theta) );
			}
		} 
			break;
		case "triangle":{		
				var p1 = { x: targetnode.x - targetnode.rx*Math.sqrt(3)/2, y: targetnode.y + targetnode.rx/2 };
				var p2 = { x: targetnode.x + targetnode.rx*Math.sqrt(3)/2, y: targetnode.y + targetnode.rx/2 };
				var p3 = { x: targetnode.x, y: targetnode.y - targetnode.ry};
				var line1 = { P1: p1, P2: p2};
				var line2 = { P1: p3, P2: p2};
				var line3 = { P1: p1, P2: p3};				
				var slope1 = (line1.P2.y -line1.P1.y)/(line1.P2.x -line1.P1.x);
				var slope2 = (line2.P2.y -line2.P1.y)/(line2.P2.x -line2.P1.x);	
				var slope3 = (line3.P2.y -line3.P1.y)/(line3.P2.x -line3.P1.x);					
				var EQline1 = {A:slope1, B: -1, C: line1.P1.y - slope1 * line1.P1.x};
				var EQline2 = {A:slope2, B: -1, C: line2.P1.y - slope2 * line2.P1.x};
				var EQline3 = {A:slope3, B: -1, C: line3.P1.y - slope3 * line3.P1.x};
				if(_theta%(Math.PI/2) === 0) {
					var EQline_theta = {A:1, B: 0 , C: -targetnode.x};
				} else {
					var slope_theta = Math.tan(_theta); 
					var EQline_theta = {A:slope_theta, B: -1 , C: targetnode.y - slope_theta * targetnode.x};
				}
				var interP = {};
				if(_theta >= Math.PI/6 & _theta <=  Math.PI*5/6){
					interP = interP_2lines(EQline1.A, EQline1.B,EQline1.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);											
				} else if ( (_theta >= Math.PI*3/2 & _theta <= Math.PI*2 )||(_theta >= 0 & _theta <= Math.PI *1/6 )){
					interP = interP_2lines(EQline2.A, EQline2.B,EQline2.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);						
				} else if (_theta >= Math.PI * 5/6 & _theta <= Math.PI *3/2) {
					interP = interP_2lines(EQline3.A, EQline3.B,EQline3.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);						
				}
				if (interP.numsolution ===1) current_r = Math.sqrt( (interP.interP.x - targetnode.x) *(interP.interP.x - targetnode.x)
																		+ (interP.interP.y - targetnode.y)*(interP.interP.y - targetnode.y));
		}
			break;
		default:;	
	}
	newr = current_r - default_RADIUSH * newr_DISCOUNT;		
	var newcx = targetnode.x + newr * Math.cos(_theta);
	var newcy = targetnode.y + newr * Math.sin(_theta);
	
	var P0 = {x: newcx , y: newcy };
	var P3 = P0;
	var P1 = {x: newcx + selfcurve_LR * Math.cos(_theta + _Angle), y: newcy + selfcurve_LR * Math.sin(_theta + _Angle)};
	var P2 = {x: newcx + selfcurve_LR * Math.cos(_theta - _Angle), y: newcy + selfcurve_LR * Math.sin(_theta - _Angle)};
	// end of use inner same figure bound as the track
	
	var handleP = { x:(P0.x * 1/8) + 3* P1.x * 1/8 +3 * P2.x * 1/8 + P3.x * 1/8,  y:(P0.y * 1/8) + 3* P1.y * 1/8 +3 * P2.y * 1/8 + P3.y * 1/8	};	
	
	var templine = "M"+ P0.x + " " + P0.y + " " + "C" + P1.x+" " + P1.y + " " + P2.x+" " + P2.y +" "+ P3.x+" " + P3.y;
	var templabel = generate_label(targetnode, targetnode, _arrowType,3);
	var targetnodeP = {x: targetnode.x, y: targetnode.y};
	var templabelP = cal_labelP(handleP,targetnodeP, targetnodeP, 3, null, null);
	var tempbcurve3p={ 
		id:"edge"+String(Edgecurrent_IdNUM),
		power:3,
		nodeid: _nodeid,
		startid:_nodeid,
		endid:_nodeid,
		theta: _theta,
		handleP: handleP,
		P0: P0,
		P1: P1,
		P2: P2,
		P3: P3,
		line: templine,	
		type: _arrowType,
		dotted: 0, 
		color: defaultCOLOR,
		strokewidth:default_strokeWIDTH,
		label: templabel,
		labelP: templabelP,
		labelFsize: defaultFONTSIZE,
		labelInitial:true,
		labelshow: true,
		curve_LR:selfcurve_LR,
		handlePshow: false,		
		handleInitial: true,
		IsAutoGenerated: false,
		selected:false
	};
	return tempbcurve3p;
}

//function： to generate an edge with the given start node and end node,  power 2 and power 3
function generate_edge(_nodes,_startid, _endid, _arrowType){ //generate by setting the nodes' ids
	var tempedge = null;
	if (_startid === _endid){
		var _nodeid = _startid;
		tempedge = generate_bcurve3p(_nodes,_nodeid, _arrowType);
	} else {
		tempedge = generate_bcurve2p(_nodes,_startid,_endid, _arrowType);
	}
	return tempedge;
}

//function： to update a bcurve of power 2 with the _nodes
function update_bcurve2p(_nodes,_bcurve2p){
			var _i = matchnodeindex(_nodes,_bcurve2p.startid);
			var _j = matchnodeindex(_nodes,_bcurve2p.endid);
			var _startP = {x: _nodes[_i].x, y:_nodes[_i].y};
			var _endP= {x: _nodes[_j].x, y:_nodes[_j].y};
			var _handleP = _bcurve2p.handleP;
			var _handleInitial = _bcurve2p.handleInitial;
			var tempcP = {x: _handleP.x * 2 - (_startP.x + _endP.x) / 2, y: _handleP.y * 2 - (_startP.y + _endP.y) / 2};
			var templine = "M"+ _startP.x + " " + _startP.y + " " + "Q" + tempcP.x+" " + tempcP.y + " " + _endP.x+" " + _endP.y ;
			var templableP = cal_labelP(_handleP, _startP, _endP, 2, null, null);
			var tempbcurve2p={
				id:_bcurve2p.id,
				power:2,
				startid: _bcurve2p.startid,
				endid: _bcurve2p.endid,
				handleP:_handleP,
				cP:tempcP,
				line: templine,
				type: _bcurve2p.type,
				dotted: _bcurve2p.dotted,
				color:_bcurve2p.color,
				strokewidth:_bcurve2p.strokewidth,
				label: _bcurve2p.label,
				labelP: templableP,
				labelFsize: _bcurve2p.labelFsize,
				labelInitial:_bcurve2p.labelInitial,
				labelshow: _bcurve2p.labelshow,
				handlePshow: _bcurve2p.handlePshow,
				handleInitial:_handleInitial,
				curve_LR:_bcurve2p.curve_LR,
				IsAutoGenerated: _bcurve2p.IsAutoGenerated,
				selected:_bcurve2p.selected
			};
		return tempbcurve2p;
}

//function： to update a bcurve of power 3 with the _nodes and the new _theta and _Angle
function update_bcurve3p(_nodes,_bcurve3p, _theta, _Angle){
	var nodeid =_bcurve3p.nodeid;
	var i = matchnodeindex(_nodes,nodeid);
	var targetnode=_nodes[i];
	var selfcurve_LR= _bcurve3p.curve_LR;
	var current_r=0;
	var newr=0;
	switch(targetnode.type){
		case "ellipse": {
			var aa=targetnode.rx;
			var bb=targetnode.ry;
			current_r = aa * bb / Math.sqrt( (bb * Math.cos(_theta) ) * (bb * Math.cos(_theta) ) +  (aa * Math.sin(_theta)) *(aa * Math.sin(_theta)) )
		}
			break;
		case "rect":{
			var current_r = 0;		
			var rectalpha = Math.atan(targetnode.ry / targetnode.rx); 
			if (_theta >= rectalpha & _theta <= Math.PI - rectalpha){
				current_r = Math.abs( targetnode.ry / Math.sin(_theta) );
			} else if ( (_theta >= 2* Math.PI - rectalpha & _theta <= 2* Math.PI) || (_theta >= 0 & _theta<= rectalpha)){
				current_r = Math.abs( targetnode.rx/ Math.cos(_theta) );
			} else if (_theta >= Math.PI+ rectalpha & _theta <= 2* Math.PI - rectalpha){
				current_r = Math.abs( targetnode.ry / Math.sin(_theta) );
			} else if (_theta >= Math.PI- rectalpha & _theta <= Math.PI + rectalpha){
				current_r = Math.abs( targetnode.rx/ Math.cos(_theta) );
			}
		} 
			break;
		case "triangle":{		
				var p1 = { x: targetnode.x - targetnode.rx*Math.sqrt(3)/2, y: targetnode.y + targetnode.rx/2 };
				var p2 = { x: targetnode.x + targetnode.rx*Math.sqrt(3)/2, y: targetnode.y + targetnode.rx/2 };
				var p3 = { x: targetnode.x, y: targetnode.y - targetnode.ry};
				var line1 = { P1: p1, P2: p2};
				var line2 = { P1: p3, P2: p2};
				var line3 = { P1: p1, P2: p3};
				var slope1 = (line1.P2.y -line1.P1.y)/(line1.P2.x -line1.P1.x);
				var slope2 = (line2.P2.y -line2.P1.y)/(line2.P2.x -line2.P1.x);	
				var slope3 = (line3.P2.y -line3.P1.y)/(line3.P2.x -line3.P1.x);					
				var EQline1 = {A:slope1, B: -1, C: line1.P1.y - slope1 * line1.P1.x};
				var EQline2 = {A:slope2, B: -1, C: line2.P1.y - slope2 * line2.P1.x};
				var EQline3 = {A:slope3, B: -1, C: line3.P1.y - slope3 * line3.P1.x};
				if(_theta%(Math.PI/2) === 0) {
					var EQline_theta = {A:1, B: 0 , C: targetnode.x};
				} else {
					var slope_theta = Math.tan(_theta); 
					var EQline_theta = {A:slope_theta, B: -1 , C: targetnode.y - slope_theta * targetnode.x};
				}
				var interP = {};
				if(_theta >= Math.PI/6 & _theta <=  Math.PI*5/6){
					interP = interP_2lines(EQline1.A, EQline1.B,EQline1.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);										
				} else if ( (_theta >= Math.PI*3/2 & _theta <= Math.PI*2 )||(_theta >= 0 & _theta <= Math.PI *1/6 )){
					interP = interP_2lines(EQline2.A, EQline2.B,EQline2.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);						
				} else if (_theta >= Math.PI * 5/6 & _theta <= Math.PI *3/2) {
					interP = interP_2lines(EQline3.A, EQline3.B,EQline3.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);						
				}
				if (interP.numsolution ===1) current_r = Math.sqrt( (interP.interP.x - targetnode.x) *(interP.interP.x - targetnode.x)
																		+ (interP.interP.y - targetnode.y)*(interP.interP.y - targetnode.y));
		}
			break;

		default:;	
	}
	newr = current_r - default_RADIUSH * newr_DISCOUNT;		
	var newcx = targetnode.x + newr * Math.cos(_theta);
	var newcy = targetnode.y + newr * Math.sin(_theta);
	
	var P0 = {x: newcx , y: newcy };
	var P3 = P0;
	var P1 = {x: newcx + selfcurve_LR * Math.cos(_theta + _Angle), y: newcy + selfcurve_LR * Math.sin(_theta + _Angle)};
	var P2 = {x: newcx + selfcurve_LR * Math.cos(_theta - _Angle), y: newcy + selfcurve_LR * Math.sin(_theta - _Angle)};
	// end of use inner same figure bound as the track
	
	var P0 = {x: newcx , y: newcy };
	var P3 = P0;
	var P1 = {x: newcx + selfcurve_LR * Math.cos(_theta + _Angle), y: newcy + selfcurve_LR * Math.sin(_theta + _Angle)};
	var P2 = {x: newcx + selfcurve_LR * Math.cos(_theta - _Angle), y: newcy + selfcurve_LR * Math.sin(_theta - _Angle)};
	
	var handleP = { x:(P0.x * 1/8) + 3* P1.x * 1/8 +3 * P2.x * 1/8 + P3.x * 1/8,  y:(P0.y * 1/8) + 3* P1.y * 1/8 +3 * P2.y * 1/8 + P3.y * 1/8	};
	var templine = "M"+ P0.x + " " + P0.y + " " + "C" + P1.x+" " + P1.y + " " + P2.x+" " + P2.y +" "+ P3.x+" " + P3.y;
	var templabel= "a"+ i +"_"+ i;
	var targetnodeP = {x: targetnode.x, y: targetnode.y};
	var templabelP = cal_labelP(handleP, targetnodeP, targetnodeP, 3, null, null);
	var tempbcurve3p={ 
		id:_bcurve3p.id,
		power:3,
		nodeid: nodeid,
		startid: nodeid,
		endid: nodeid,
		theta: _theta,
		handleP: handleP,
		P0: P0,
		P1: P1,
		P2: P2,
		P3: P3,
		line: templine,		
		type: _bcurve3p.type,
		dotted: _bcurve3p.dotted, 
		color:_bcurve3p.color,
		strokewidth:_bcurve3p.strokewidth,
		label: _bcurve3p.label,
		labelP: templabelP,
		labelFsize: _bcurve3p.labelFsize,
		labelInitial:_bcurve3p.labelInitial,
		labelshow: _bcurve3p.labelshow,
		curve_LR: _bcurve3p.curve_LR,
		handlePshow: _bcurve3p.handlePshow,
		handleInitial: _bcurve3p.handleInitial,
		IsAutoGenerated: _bcurve3p.IsAutoGenerated,
		selected:false
	};	
	return tempbcurve3p;
}

//function： to update a bcurve with the new handleP or new _nodes, power 2 or power 3
function update_bcurve(_nodes,_bcurve){
	var tempedge = null;
	if(_bcurve.power ===2){
		var tempbcurve2p = update_bcurve2p(_nodes,_bcurve);	
		tempedge = tempbcurve2p;
	}else if (_bcurve.power ===3){	
		var nodeid =_bcurve.nodeid;
		var i = matchnodeindex(_nodes,nodeid);
		var targetnode=_nodes[i];
		var nodeP = {x: targetnode.x, y: targetnode.y};
		var handleP = _bcurve.handleP; 
		var newtheta = 0;			
		newtheta = calculate_theta(nodeP, handleP);	
		var tempbcurve3p =  update_bcurve3p(_nodes,_bcurve, newtheta, selfpathANGLE_default);	
		tempedge = tempbcurve3p;
	}	
	return tempedge;
}

//function： to update the _edges with the new _nodes, power 2 or power 3
function update_edges(_nodes,_edges){
	var temp=[];
	for (var i=0; i< _edges.length; i++){
		temp.push(update_bcurve(_nodes,_edges[i]));
	}
	return temp;
}

//function： to find the duplicate bcurve/edge,  power 2 and power 3
function lookfor_duplicatedbcurve(_nodes,_edges,_startid,_endid,_type){ 

	var found_bcurve_index = -1;
	for (var i =0; i< _edges.length; i++) {	
		if (_edges[i].power ===3) {
			if (_edges[i].nodeid === _startid & _edges[i].nodeid === _endid & _edges[i].type ===_type) {
				found_bcurve_index = i;				
				return found_bcurve_index;
			}
		} else if (_edges[i].power ===2){
			switch(_type){
				case "bi":
					{	
							if (_edges[i].startid === _startid & _edges[i].endid === _endid & _edges[i].type === _type){
									found_bcurve_index = i;
									return found_bcurve_index;
							}
							if (_edges[i].startid === _endid & _edges[i].endid === _startid & _edges[i].type === _type){
									found_bcurve_index = i;
									return found_bcurve_index;
							}
					}
					break;
				case "uni":
					{						
						if (_edges[i].startid === _startid & _edges[i].endid === _endid & _edges[i].type === _type){
							found_bcurve_index = i;
							return found_bcurve_index;
						}
					}
					break;
				default: ;
			} // end of switch
		}//end if power ===2 
	} // end of for loop
	//console.log("notduplicated!");
	return found_bcurve_index;
}

//function： to decide if the node is dependent 
function Is_dependentnode(_node,_nodes,_edges){
	var Is_dependentnode = false;
	for(var i=0; i<_edges.length;i++){
		if (_edges[i].power === 2 & _edges[i].type === "uni"){
			var startnode = _nodes[matchnodeindex(_nodes,_edges[i].startid)];
			var endnode = _nodes[matchnodeindex(_nodes,_edges[i].endid)];
			if  (_node.id === endnode.id & (startnode.type === "rect" || startnode.type === "ellipse") ) {
				Is_dependentnode = true;
				i=edges.length;
			}			
		}
	}
	return Is_dependentnode;
}

//function：  to find the crossover point between the bcurve and its end/start node margin, power 2
function lookup_interP_with_oneNode_bcurve2p(_nodes, _bcurve2p, _witchnode){

	if (_witchnode==="startP"){
		var startt=0;
		var endt=1;
		var stept= 1/Nt;
		var stopt = 2;
		var _node= _nodes[matchnodeindex( _nodes, _bcurve2p.startid)];
	} else if (_witchnode ==="endP") {
		var startt=1;
		var endt=0;
		var stept= (-1) * 1/Nt;
		var stopt =-1;
		var _node= _nodes[matchnodeindex( _nodes, _bcurve2p.endid)];
	}

	var interP = {x: _node.x+ _node.rx, y: _node.y+ _node.ry};
	var inter_t = startt+0.001;
	var interP_out = {x: _node.x+60, y: _node.y+60};
	var inter_t_out = startt+0.002;
	var Isfound = false;
	
	var _startP= _nodes[ matchnodeindex(_nodes, _bcurve2p.startid)];
	var _endP = _nodes[ matchnodeindex(_nodes, _bcurve2p.endid)];
	var _cP = _bcurve2p.cP;	
	
	switch (_node.type){
		case "ellipse": 
			{
				var aa = _node.rx; 
				var bb = _node.ry; 
				var centerP = {x: _node.x, y: _node.y};
				var out_of_circumference=false;
				var t=startt;
				var vt=t;
				if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
				while( vt<=endt){
					var tx = (1-t)*(1-t)*_startP.x + 2*t*(1-t)*_cP.x + t*t*_endP.x ;
					var ty = (1-t)*(1-t)*_startP.y + 2*t*(1-t)*_cP.y + t*t*_endP.y ;
					var tP = {x: tx, y: ty}; 
					if ( tP.x <= centerP.x - aa || tP.x >= centerP.x + aa  || tP.y <= centerP.y - bb  || tP.y >= centerP.y + bb ){
						out_of_circumference=true;
					} else if ( ( ( tP.x - centerP.x) * (tP.x - centerP.x) / (aa * aa) +  (tP.y - centerP.y) * (tP.y - centerP.y) / (bb * bb) ) >= 1 ) {
						out_of_circumference=true;
					}
					if ( out_of_circumference){
						Isfound = true;
						interP = tP;
						inter_t = t;
						t = stopt; 
						inter_t_out = inter_t + 50 * stept  ;
						var tx_out = (1-inter_t_out)*(1-inter_t_out)*_startP.x + 2*inter_t_out*(1-inter_t_out)*_cP.x + inter_t_out*inter_t_out*_endP.x ;
						var ty_out = (1-inter_t_out)*(1-inter_t_out)*_startP.y + 2*inter_t_out*(1-inter_t_out)*_cP.y + inter_t_out*inter_t_out*_endP.y ;
						interP_out = {x: tx_out, y: ty_out};	
					}				
						t = t + stept;
						vt=t;
						if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
					
				}// end of while loop === for (var t=startt; t<= endt; t+= stept){}
			}
			break;
		case "rect": 
			{	
				var p1 = {x:_node.x - _node.rx, y: _node.y - _node.ry};
				var p2 = {x:_node.x + _node.rx, y: _node.y - _node.ry};
				var p3 = {x:_node.x + _node.rx, y: _node.y + _node.ry};
				var p4 = {x:_node.x - _node.rx, y: _node.y + _node.ry};
				var line1 = {P1: p1, P2:p2};
				var line2 = {P1: p2, P2:p3}; 										
				var line3 = {P1: p4, P2:p3};										
				var line4 = {P1: p1, P2:p4};
				
				var out_of_circumference=false;
				var t=startt;
				var vt=t;
				if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
				while( vt<=endt){
					var tx = (1-t)*(1-t)*_startP.x + 2*t*(1-t)*_cP.x + t*t*_endP.x ;
					var ty = (1-t)*(1-t)*_startP.y + 2*t*(1-t)*_cP.y + t*t*_endP.y ;
					var tP = {x: tx, y: ty}; 
					if ( tP.x <= _node.x - _node.rx || tP.x >= _node.x + _node.rx  || tP.y <= _node.y - _node.ry  || tP.y >= _node.y + _node.ry ){
						out_of_circumference=true;
					}
					if ( out_of_circumference){
						Isfound = true;
						interP = tP;
						inter_t = t;
						t = stopt; 
						inter_t_out = inter_t + 50 * stept  ;
						var tx_out = (1-inter_t_out)*(1-inter_t_out)*_startP.x + 2*inter_t_out*(1-inter_t_out)*_cP.x + inter_t_out*inter_t_out*_endP.x ;
						var ty_out = (1-inter_t_out)*(1-inter_t_out)*_startP.y + 2*inter_t_out*(1-inter_t_out)*_cP.y + inter_t_out*inter_t_out*_endP.y ;
						interP_out = {x: tx_out, y: ty_out};	
					}				
						t = t + stept;
						vt=t;
						if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
					
				}// end of while loop === for (var t=startt; t<= endt; t+= stept){}
			}
			break;
		case "triangle":
			{			
				var p1 = { x: _node.x - _node.rx*Math.sqrt(3)/2, y: _node.y+_node.rx/2 };
				var p2 = { x: _node.x + _node.rx*Math.sqrt(3)/2, y: _node.y+_node.rx/2 };
				var p3 = { x: _node.x, y: _node.y - _node.ry};
				var line1 = { P1: p1, P2: p2};
				var line2 = { P1: p3, P2: p2};
				var line3 = { P1: p1, P2: p3};
				var out_of_circumference=false;
				var t=startt;
				var vt=t;
				if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
				while( vt<=endt){
					var tx = (1-t)*(1-t)*_startP.x + 2*t*(1-t)*_cP.x + t*t*_endP.x ;
					var ty = (1-t)*(1-t)*_startP.y + 2*t*(1-t)*_cP.y + t*t*_endP.y ;
					var tP = {x: tx, y: ty};
					if ( tP.x <= _node.x - _node.rx*Math.sqrt(3)/2 || tP.x >= _node.x + _node.rx*Math.sqrt(3)/2  || tP.y <= _node.y - _node.ry || tP.y >=  _node.y+_node.rx/2 ){
						out_of_circumference=true;
					} else {
						var tri_y;
						var a2 = line2.P1.y;
						var b2 = (line2.P2.y - line2.P1.y)/(line2.P2.x - line2.P1.x);
						var a3 = line3.P1.y;
						var b3 = (line3.P2.y - line3.P1.y)/(line3.P2.x - line3.P1.x);
						if (tP.x <= _node.x) {
							tri_y = a3 +  b3 * (tP.x - line3.P1.x);
						} else {
							tri_y = a2 +  b2 * (tP.x - line2.P1.x);
						}
							if (tP.y <= tri_y ) {out_of_circumference=true;	}				
					}
					if ( out_of_circumference){
						Isfound = true;
						interP = tP;
						inter_t = t;
						t = stopt;
						inter_t_out = inter_t + 50 * stept  ;
						var tx_out = (1-inter_t_out)*(1-inter_t_out)*_startP.x + 2*inter_t_out*(1-inter_t_out)*_cP.x + inter_t_out*inter_t_out*_endP.x ;
						var ty_out = (1-inter_t_out)*(1-inter_t_out)*_startP.y + 2*inter_t_out*(1-inter_t_out)*_cP.y + inter_t_out*inter_t_out*_endP.y ;
						interP_out = {x: tx_out, y: ty_out};	
					}				
						t = t + stept;
						vt=t;
						if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
					
				}// end of while loop === for (var t=startt; t<= endt; t+= stept){}
			}
			break;
		
		default:	;
	}// end of switch (_node.type)
	var temp = {Isfound: Isfound, interP: interP, inter_t: inter_t, interP_out: interP_out, inter_t_out: inter_t_out};
	return temp;
}

//function：  to find the crossover point between the bcurve and its end/start node margin, power 3
function lookup_interP_with_oneNode_bcurve3p(_nodes,_bcurve3p, _witchnode){

	if (_witchnode==="startP"){
		var startt=0;
		var endt=1;
		var stept= 1/Nt;
		var stopt = 2;
		
	} else if (_witchnode ==="endP") {
		var startt=1;
		var endt=0;
		var stept= (-1) * 1/Nt;
		var stopt =-1;
	}
	var _node= _nodes[matchnodeindex( _nodes, _bcurve3p.nodeid)];
	var interP = {x: _node.x+ _node.rx, y: _node.y+ _node.ry};
	var inter_t = startt+0.001;
	var interP_out = {x: _node.x+60, y: _node.y+60};
	var inter_t_out = startt+0.002;
	var Isfound = false;
	
	var _P0 = _bcurve3p.P0;
	var _P1 = _bcurve3p.P1;
	var _P2 = _bcurve3p.P2;	
	var _P3 = _bcurve3p.P3;	
	
	switch (_node.type){
		case "ellipse": 
			{
				var aa = _node.rx; 
				var bb = _node.ry; 				
				var centerP = {x: _node.x, y: _node.y};
				var out_of_circumference=false;
				var t=startt;
				var vt=t;
				if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
				while( vt<=endt){
					var tx = (1-t)*(1-t)*(1-t)*_P0.x + 3 *(1-t)*(1-t)* t *_P1.x + 3*(1-t)*t*t* _P2.x+ t*t*t*_P3.x ;
					var ty = (1-t)*(1-t)*(1-t)*_P0.y + 3 *(1-t)*(1-t)* t *_P1.y + 3*(1-t)*t*t* _P2.y+ t*t*t*_P3.y ;
					var tP = {x: tx, y: ty}; 
					if ( tP.x <= centerP.x - aa || tP.x >= centerP.x + aa  || tP.y <= centerP.y - bb  || tP.y >= centerP.y + bb ){
						out_of_circumference=true;
					} else if ( ( ( tP.x - centerP.x) * (tP.x - centerP.x) / (aa * aa) +  (tP.y - centerP.y) * (tP.y - centerP.y) / (bb * bb) ) >= 1 ) {
						out_of_circumference=true;
					}
					if ( out_of_circumference){
						Isfound = true;
						interP = tP;
						inter_t = t;
						t = stopt; 						
						inter_t_out = inter_t + 50 * stept  ;
						var tx_out = (1-inter_t_out)*(1-inter_t_out)*(1-inter_t_out)*_P0.x + 3*(1-inter_t_out)*(1-inter_t_out)*inter_t_out*_P1.x+ 3*(1-inter_t_out)*inter_t_out*inter_t_out*_P2.x + inter_t_out*inter_t_out*inter_t_out*_P3.x ;
						var ty_out = (1-inter_t_out)*(1-inter_t_out)*(1-inter_t_out)*_P0.y + 3*(1-inter_t_out)*(1-inter_t_out)*inter_t_out*_P1.y+ 3*(1-inter_t_out)*inter_t_out*inter_t_out*_P2.y + inter_t_out*inter_t_out*inter_t_out*_P3.y ;
						interP_out = {x: tx_out, y: ty_out};	
					}				
						t = t + stept;
						vt=t;
						if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
					
				}// end of while loop === for (var t=startt; t<= endt; t+= stept){}
			}
			break;
		case "rect": 
			{	
				var p1 = {x:_node.x - _node.rx, y: _node.y - _node.ry};
				var p2 = {x:_node.x + _node.rx, y: _node.y - _node.ry};
				var p3 = {x:_node.x + _node.rx, y: _node.y + _node.ry};
				var p4 = {x:_node.x - _node.rx, y: _node.y + _node.ry};
				var line1 = {P1: p1, P2:p2};
				var line2 = {P1: p2, P2:p3}; 										
				var line3 = {P1: p4, P2:p3};										
				var line4 = {P1: p1, P2:p4};
				
				var out_of_circumference=false;
				var t=startt;
				var vt=t;
				if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
				while( vt<=endt){
					var tx = (1-t)*(1-t)*(1-t)*_P0.x + 3 *(1-t)*(1-t)* t *_P1.x + 3*(1-t)*t*t* _P2.x+ t*t*t*_P3.x ;
					var ty = (1-t)*(1-t)*(1-t)*_P0.y + 3 *(1-t)*(1-t)* t *_P1.y + 3*(1-t)*t*t* _P2.y+ t*t*t*_P3.y ;
					var tP = {x: tx, y: ty};
					if ( tP.x <= _node.x - _node.rx || tP.x >= _node.x + _node.rx  || tP.y <= _node.y - _node.ry  || tP.y >= _node.y + _node.ry ){
						out_of_circumference=true;
					}
					if ( out_of_circumference){
						Isfound = true;
						interP = tP;
						inter_t = t;
						t = stopt; 						
						inter_t_out = inter_t + 50 * stept  ;
						var tx_out = (1-inter_t_out)*(1-inter_t_out)*(1-inter_t_out)*_P0.x + 3*(1-inter_t_out)*(1-inter_t_out)*inter_t_out*_P1.x+ 3*(1-inter_t_out)*inter_t_out*inter_t_out*_P2.x + inter_t_out*inter_t_out*inter_t_out*_P3.x ;
						var ty_out = (1-inter_t_out)*(1-inter_t_out)*(1-inter_t_out)*_P0.y + 3*(1-inter_t_out)*(1-inter_t_out)*inter_t_out*_P1.y+ 3*(1-inter_t_out)*inter_t_out*inter_t_out*_P2.y + inter_t_out*inter_t_out*inter_t_out*_P3.y ;
						interP_out = {x: tx_out, y: ty_out};	
					}				
						t = t + stept;
						vt=t;
						if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
					
				}// end of while loop === for (var t=startt; t<= endt; t+= stept){}
			}
			break;
		case "triangle":
			{			
				var p1 = { x: _node.x - _node.rx*Math.sqrt(3)/2, y: _node.y+_node.rx/2 };
				var p2 = { x: _node.x + _node.rx*Math.sqrt(3)/2, y: _node.y+_node.rx/2 };
				var p3 = { x: _node.x, y: _node.y - _node.ry};
				var line1 = { P1: p1, P2: p2};
				var line2 = { P1: p3, P2: p2};
				var line3 = { P1: p1, P2: p3};
				var out_of_circumference=false;
				var t=startt;
				var vt=t;
				if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
				while( vt<=endt){
					var tx = (1-t)*(1-t)*(1-t)*_P0.x + 3 *(1-t)*(1-t)* t *_P1.x + 3*(1-t)*t*t* _P2.x+ t*t*t*_P3.x ;
					var ty = (1-t)*(1-t)*(1-t)*_P0.y + 3 *(1-t)*(1-t)* t *_P1.y + 3*(1-t)*t*t* _P2.y+ t*t*t*_P3.y ;
					var tP = {x: tx, y: ty}; 
					if ( tP.x <= _node.x - _node.rx*Math.sqrt(3)/2 || tP.x >= _node.x + _node.rx*Math.sqrt(3)/2  || tP.y <= _node.y - _node.ry || tP.y >=  _node.y+_node.rx/2 ){
						out_of_circumference=true;
					} else {
						var tri_y;
						var a2 = line2.P1.y;
						var b2 = (line2.P2.y - line2.P1.y)/(line2.P2.x - line2.P1.x);
						var a3 = line3.P1.y;
						var b3 = (line3.P2.y - line3.P1.y)/(line3.P2.x - line3.P1.x);
						if (tP.x <= _node.x) {
							tri_y = a3 +  b3 * (tP.x - line3.P1.x);
						} else {
							tri_y = a2 +  b2 * (tP.x - line2.P1.x);
						}
							if (tP.y <= tri_y ) {out_of_circumference=true;	}				
					}
					if ( out_of_circumference){
						Isfound = true;
						interP = tP;
						inter_t = t;
						t = stopt; 						
						inter_t_out = inter_t + 50 * stept  ;
						var tx_out = (1-inter_t_out)*(1-inter_t_out)*(1-inter_t_out)*_P0.x + 3*(1-inter_t_out)*(1-inter_t_out)*inter_t_out*_P1.x+ 3*(1-inter_t_out)*inter_t_out*inter_t_out*_P2.x + inter_t_out*inter_t_out*inter_t_out*_P3.x ;
						var ty_out = (1-inter_t_out)*(1-inter_t_out)*(1-inter_t_out)*_P0.y + 3*(1-inter_t_out)*(1-inter_t_out)*inter_t_out*_P1.y+ 3*(1-inter_t_out)*inter_t_out*inter_t_out*_P2.y + inter_t_out*inter_t_out*inter_t_out*_P3.y ;
						interP_out = {x: tx_out, y: ty_out};	
					}				
						t = t + stept;
						vt=t;
						if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
					
				}// end of while loop === for (var t=startt; t<= endt; t+= stept){}
			}
			break;
		
		default:	;
	}// end of switch (_node.type)
	var temp = {Isfound: Isfound, interP: interP, inter_t: inter_t, interP_out: interP_out, inter_t_out: inter_t_out};
	return temp;
}

//function： to generate the tangent line of a given bcurve2p and its ends
function generate_tangent_bcurve2p(_nodes,_bcurve2p){
		var temp1 = lookup_interP_with_oneNode_bcurve2p(_nodes,_bcurve2p,"startP");
		var temp2 = lookup_interP_with_oneNode_bcurve2p(_nodes,_bcurve2p,"endP");
		var Isfound1 = temp1.Isfound;
		var Isfound2 = temp2.Isfound;
		var interP1 = temp1.interP;
		var interP2 = temp2.interP;
		var inter_t1 = temp1.inter_t;
		var inter_t2 = temp2.inter_t;
		var interP_out1 = temp1.interP_out;
		var interP_out2 = temp2.interP_out;
		var inter_t_out1 = temp1.inter_t_out;
		var inter_t_out2 = temp2.inter_t_out;		
	
		var tangentline1 = {P1: interP_out1, P2: interP1};	
		var tangentline2 = {P1: interP_out2, P2: interP2};
		var t_tangent = {
			startid: _bcurve2p.startid,
			endid: _bcurve2p.endid,
			type: _bcurve2p.type,
			interP1: interP1,
			interP2: interP2,
			interP_out1: interP_out1,
			interP_out2: interP_out2,
			tangentline1: "M"+ interP_out1.x +","+ interP_out1.y+" "+"L"+interP1.x+","+interP1.y,
			tangentline2: "M"+ interP_out2.x +","+ interP_out2.y+" "+"L"+interP2.x+","+interP2.y			
		};
		return t_tangent;
}

//function： to generate the tangent line of a given bcurve3p and its ends
function generate_tangent_bcurve3p(_nodes,_bcurve3p){
		var temp1 = lookup_interP_with_oneNode_bcurve3p(_nodes,_bcurve3p,"startP");
		var temp2 = lookup_interP_with_oneNode_bcurve3p(_nodes,_bcurve3p,"endP");
		var Isfound1 = temp1.Isfound;
		var Isfound2 = temp2.Isfound;
		var interP1 = temp1.interP;
		var interP2 = temp2.interP;
		var inter_t1 = temp1.inter_t;
		var inter_t2 = temp2.inter_t;
		var interP_out1 = temp1.interP_out;
		var interP_out2 = temp2.interP_out;
		var inter_t_out1 = temp1.inter_t_out;
		var inter_t_out2 = temp2.inter_t_out;		
	
		var tangentline1 = {P1: interP_out1, P2: interP1};	
		var tangentline2 = {P1: interP_out2, P2: interP2};
		var t_tangent = {
			startid: _bcurve3p.nodeid,
			endid: _bcurve3p.nodeid,
			type: _bcurve3p.type,
			interP1: interP1,
			interP2: interP2,
			interP_out1: interP_out1,
			interP_out2: interP_out2,
			tangentline1: "M"+ interP_out1.x +","+ interP_out1.y+" "+"L"+interP1.x+","+interP1.y,
			tangentline2: "M"+ interP_out2.x +","+ interP_out2.y+" "+"L"+interP2.x+","+interP2.y	
		};
		return t_tangent;
}

//function： to generate the tangent line of a given bcurve and its ends, power 2 and power 3
function generate_tangent(_nodes,_bcurve){
	var t_tangent = null;
	if (_bcurve.power ===2) {
		t_tangent = generate_tangent_bcurve2p(_nodes,_bcurve);
	} else if (_bcurve.power === 3) {
		t_tangent = generate_tangent_bcurve3p(_nodes,_bcurve);
	}		
	return t_tangent;
}

//function： to generate the tangent line of the edges and theirs ends
function generate_tangents(_nodes,_edges){
	var tangents = [];
	for (var i =0; i< _edges.length; i++){
		var t_tangent = null;
		t_tangent = generate_tangent(_nodes,_edges[i]);
		tangents.push(t_tangent);
	}	
	return tangents;
}

//function： to move the handleP to keep the shage of the bcurve after the one of its ends /nodes moved
function generate_new_handleP_for_movednode(_nodes,_bcurve2p,_witchnode, _originP){
	var newhandleP = _bcurve2p.handleP;
	var _i = matchnodeindex(_nodes,_bcurve2p.startid);
	var _j = matchnodeindex(_nodes,_bcurve2p.endid);
	var _startP = {x: _nodes[_i].x, y:_nodes[_i].y};
	var _endP= {x: _nodes[_j].x, y:_nodes[_j].y};
	var _handleP = _bcurve2p.handleP;
	switch(_witchnode){
		case "startP": {
			var angles = calculate_angles_of_triangle(_originP, _handleP, _endP);
		} break;
		case "endP":{
			var angles = calculate_angles_of_triangle(_startP, _handleP, _originP);
		} break;
		default: 
			var angles = calculate_angles_of_triangle(_originP, _handleP, _endP);
	}
	if (angles.Is_success){		
		var angle_P0 = angles.angle_P0; 
		var angle_P2 = angles.angle_P2;
		var angle_P1 = angles.angle_P1; 
		var angle_anticlockwise = angles.angle_anticlockwise;
		switch(_witchnode){
			case "startP":{	
				var origin_line_P0_P1 = {P1: _originP, P2:_handleP};
				var origin_length_P0_P1 = Math.sqrt((origin_line_P0_P1.P2.x - origin_line_P0_P1.P1.x)*(origin_line_P0_P1.P2.x - origin_line_P0_P1.P1.x)
												+(origin_line_P0_P1.P2.y - origin_line_P0_P1.P1.y)*(origin_line_P0_P1.P2.y - origin_line_P0_P1.P1.y));
				var origin_line_P0_P2 = {P1: _originP, P2: _endP};
				var origin_length_P0_P2 = Math.sqrt((origin_line_P0_P2.P2.x - origin_line_P0_P2.P1.x)*(origin_line_P0_P2.P2.x - origin_line_P0_P2.P1.x)
												+(origin_line_P0_P2.P2.y - origin_line_P0_P2.P1.y)*(origin_line_P0_P2.P2.y - origin_line_P0_P2.P1.y));
				var new_line_P0_P2 = {P1: _startP, P2: _endP};
				var new_length_P0_P2 = Math.sqrt((new_line_P0_P2.P2.x - new_line_P0_P2.P1.x)*(new_line_P0_P2.P2.x - new_line_P0_P2.P1.x)
												+(new_line_P0_P2.P2.y - new_line_P0_P2.P1.y)*(new_line_P0_P2.P2.y - new_line_P0_P2.P1.y));			
				var new_length_P0_P1 = origin_length_P0_P1 * new_length_P0_P2/origin_length_P0_P2;
				var temp_new_theta_P0_P2 = Math.acos( (new_line_P0_P2.P2.x -new_line_P0_P2.P1.x ) / new_length_P0_P2);//[0,PI] for acos()
				var new_theta_P0_P2;
				if (new_line_P0_P2.P2.y >= new_line_P0_P2.P1.y){
					new_theta_P0_P2 = temp_new_theta_P0_P2;
				} else {
					new_theta_P0_P2 = Math.PI*2 - temp_new_theta_P0_P2;
				}
				var new_theta_P0_P1;
				if(angle_anticlockwise) {//anticlockwise for P0 but clockwise for P2
					new_theta_P0_P1 = new_theta_P0_P2 + angle_P0;
				} else {//clockwise for P0 but anticlockwise for P2
					new_theta_P0_P1 = new_theta_P0_P2 - angle_P0;
				}
				var tempx = new_line_P0_P2.P1.x + new_length_P0_P1 * Math.cos(new_theta_P0_P1);
				var tempy = new_line_P0_P2.P1.y + new_length_P0_P1 * Math.sin(new_theta_P0_P1);
				newhandleP = {x: tempx, y: tempy};
				
			}
				break;
			case "endP"	:{
				var origin_line_P2_P1 = {P1: _originP, P2:_handleP};
				var origin_length_P2_P1 = Math.sqrt((origin_line_P2_P1.P2.x - origin_line_P2_P1.P1.x)*(origin_line_P2_P1.P2.x - origin_line_P2_P1.P1.x)
												+(origin_line_P2_P1.P2.y - origin_line_P2_P1.P1.y)*(origin_line_P2_P1.P2.y - origin_line_P2_P1.P1.y));
				var origin_line_P2_P0 = {P1: _originP, P2: _startP};
				var origin_length_P2_P0 = Math.sqrt((origin_line_P2_P0.P2.x - origin_line_P2_P0.P1.x)*(origin_line_P2_P0.P2.x - origin_line_P2_P0.P1.x)
												+(origin_line_P2_P0.P2.y - origin_line_P2_P0.P1.y)*(origin_line_P2_P0.P2.y - origin_line_P2_P0.P1.y));
				var new_line_P2_P0 = {P1: _endP, P2: _startP};
				var new_length_P2_P0 = Math.sqrt((new_line_P2_P0.P2.x - new_line_P2_P0.P1.x)*(new_line_P2_P0.P2.x - new_line_P2_P0.P1.x)
												+(new_line_P2_P0.P2.y - new_line_P2_P0.P1.y)*(new_line_P2_P0.P2.y - new_line_P2_P0.P1.y));			
				var new_length_P2_P1 = origin_length_P2_P1 * new_length_P2_P0/origin_length_P2_P0;
				var temp_new_theta_P2_P0 = Math.acos( (new_line_P2_P0.P2.x -new_line_P2_P0.P1.x ) / new_length_P2_P0);//[0,PI] for acos()
				var new_theta_P2_P0; 
				if (new_line_P2_P0.P2.y>= new_line_P2_P0.P1.y){
					new_theta_P2_P0 = temp_new_theta_P2_P0;
				} else {
					new_theta_P2_P0 = Math.PI*2 - temp_new_theta_P2_P0;
				}
				var new_theta_P2_P1;
				if(angle_anticlockwise) {//anticlockwise for P0 but clockwise for P2
					new_theta_P2_P1 = new_theta_P2_P0 - angle_P2;
				} else {//clockwise for P0 but anticlockwise for P2
					new_theta_P2_P1 = new_theta_P2_P0 + angle_P2;
				}
				var tempx = new_line_P2_P0.P1.x + new_length_P2_P1 * Math.cos(new_theta_P2_P1);
				var tempy = new_line_P2_P0.P1.y + new_length_P2_P1 * Math.sin(new_theta_P2_P1);
				newhandleP = {x: tempx, y: tempy};
			}
				break;
			default:;
		}// end switch
	}// end if (alpha_beta.Is_success)
	
	return newhandleP;
}

