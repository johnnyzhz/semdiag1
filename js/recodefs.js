/***************************************************
 * semdiag: draw SEM path diagram interactively    *
 * Authors: Yujiao Mai, Zhiyong Zhang, Ke-Hai Yuan *
 * Copyright 2015-2015, psychstat.org              *
 * Licensed under the MIT License (MIT)            *
 * Current software version 1.0                    *
 * Support email for questions zzhang4@nd.edu      *
 *                             ymai@nd.edu         * 
 ***************************************************/

/* the file '': functions for recoding the diagram to svg syntax, diag syntax, and graph data*/
///////////////////////////////////////////////////////////////////////// 
function GraphToText2() {
			var r = "MARKS:"
			r += '\n'+'Nodecurrent_IdNUM:'+ Nodecurrent_IdNUM
				+','+'Edgecurrent_IdNUM:'+Edgecurrent_IdNUM
				+','+'Elli_current_TitleNUM:'+Elli_current_TitleNUM
				+','+'Rec_current_TitleNUM:'+Rec_current_TitleNUM
				+','+'h:'+h
				+','+'w:'+w;
			r += '\n'+'NODES:';
            for (var i = 0; i < nodes.length; i++) {
                var tempnode = nodes[i];
                r += '\n' + 'id:'+ tempnode.id
							+ ','+'type:'+ tempnode.type 
							+ ',' +'x:'+ tempnode.x 
							+ ','+'y:' + tempnode.y 
							+ ',' +'rx:'+ tempnode.rx 
							+ ',' +'ry:'+ tempnode.ry 
							+ ',' +'color:'+ tempnode.color 
							+ ','+ 'strokedotted:'+ tempnode.strokedotted
							+','+'strokewidth:'+tempnode.strokewidth
							+ ',' + 'title:'+tempnode.title
							+ ','+ 'fontsize:'+ tempnode.fontsize;
            }
            r += '\n'+'EDGES:';
            for (var i = 0; i < edges.length; i++) {
                var tempedge = edges[i];
				var startnode;
				var endnode;
				var curve_LR=-1;
				switch(tempedge.power){
					case 2:
						startnode =nodes[matchnodeindex(nodes,tempedge.startid)];
						endnode = nodes[matchnodeindex(nodes,tempedge.endid)];						
						break;
					case 3:
						startnode = nodes[matchnodeindex(nodes,tempedge.nodeid)];
						endnode=startnode;
						curve_LR= tempedge.curve_LR;
						break;
				}
				var t_labelInitial=1;if (tempedge.labelInitial){t_labelInitial=1;} else {t_lableInitial=0;}
				var t_handleInitial=1;if (tempedge.handleInitial){t_handleInitial=1;} else {t_handleInitial=0;}
				var t_IsAutoGenerated=1;if (tempedge.IsAutoGenerated){t_IsAutoGenerated=1;} else {t_IsAutoGenerated=0;}
				r += '\n' + 'id:'+ tempedge.id
					+','+'startnodeid:'+startnode.id
					+ ',' +'endnodeid:'+ endnode.id 
					+ ',' + 'type:'+ tempedge.type
					+ ',' + 'handlePx:'+ tempedge.handleP.x 
					+ ',' + 'handlePy:'+tempedge.handleP.y 
					+',' + 'color:'+tempedge.color
					+','+'dotted:'+tempedge.dotted
					+','+'strokewidth:'+tempedge.strokewidth
					+ ',' + 'label:'+tempedge.label
					+','+'labelPx:'+tempedge.labelP.x
					+','+'labelPy:'+tempedge.labelP.y
					+','+'labelFsize:'+tempedge.labelFsize
					+','+'labelInitial:'+t_labelInitial
					+','+'curve_LR:'+curve_LR
					+','+'handleInitial:'+t_handleInitial
					+','+'IsAutoGenerated:'+t_IsAutoGenerated
					;
             
            }
			
           r += '\n'+'NOTES:';
            for (var i = 0; i < notes.length; i++) {
                var tempnote = notes[i];
				r += '\n' +'x:'+tempnote.x
					+ ',' +'y:'+ tempnote.y
					+',' + 'color:'+tempnote.color
					+ ',' + 'text:'+tempnote.text
					+','+'fontsize:'+tempnote.fontsize
					;
             
            }
            return r;
}

function AdjustChartSize(_nodes, _edges, _edges_tangents, _notes){
	var tempw=0;
	var temph=0;
	for (var k=0; k<_nodes.length;k++){
		var tempx=_nodes[k].x+_nodes[k].rx*2;
		var tempy=_nodes[k].y+_nodes[k].ry*2;
		if (tempw<tempx) tempw=tempx;
		if (temph<tempy) temph=tempy;
	}
	for (var l=0; l<_edges.length;l++){
		var tempx = _edges[l].handleP.x+cPr;
		var tempy = _edges[l].handleP.y + cPr;
		if (tempw<tempx) tempw=tempx;
		if (temph<tempy) temph=tempy;
		tempx = _edges[l].labelP.x+default_RADIUSH*2;
		tempy = _edges[l].labelP.y+default_RADIUSV*2;
		if (tempw<tempx) tempw=tempx;
		if (temph<tempy) temph=tempy;
	}	
	tempw += default_RADIUSH*2;
	temph += default_RADIUSV*2;
	tempw =  (tempw);
	temph =  (temph);
	
	return {w: tempw, h: temph};
}

function GraphFromText2(str) {
		var newnodes=[];
		var newedges=[];
		var newnotes=[];
		var newmarks={};
	
        var lines = str.split('\n'); 
        var sta = '';		
        for (var i = 0; i < lines.length; i++) {
            var s = lines[i]; var l=s.length; 
			switch(s.substr(0,l-1)){ 
				case 'MARKS:':{
					sta='mark'; 
				} break;
				case 'NODES:': {
					sta = 'node';
				}break;
				case 'EDGES:': {
					sta = 'edge';
				} break;
				case 'NOTES:': {
					sta = 'note';
				} break;
				default: {
					var ss = s.split(',');
					
					switch(sta){
						case 'node': 
							if(ss.length>0 ) {					
								var newnode;
								var t_id='';
								var t_type='ellipse';
								var t_x=default_RADIUSH;
								var t_y=default_RADIUSV;
								var t_rx=default_RADIUSH;
								var t_ry=default_RADIUSV;
								var t_color=backgroundCOLOR;
								var t_dotted='none';
								var t_title='';
								var t_fontsize=defaultFONTSIZE;
								var t_strokewidth=default_strokeWIDTH;
								var t_selected=false;
								for(var j=0; j< ss.length; j++){
									var sss =ss[j].split(':'); 
									var attri_name=sss[0]; var l1=attri_name.length; attri_name=attri_name.substr(0,l1);
									var attri_value=sss[1]; var l2=attri_value.length;attri_value=attri_value.substr(0,l2);
									switch(attri_name){
										case 'id': t_id=attri_value;break;
										case 'type':t_type =attri_value;break;
										case 'x':t_x=attri_value;break;
										case 'y':t_y=attri_value;break;
										case 'rx':t_rx=attri_value;break;
										case 'ry':t_ry=attri_value;break;
										case 'color':t_color=attri_value;break;
										case 'strokedotted':t_dotted=attri_value;break;
										case 'title':t_title=attri_value;break;
										case 'fontsize':t_fontsize=attri_value;break;
										case 'strokewidth':t_strokewidth=attri_value;break;										
										default:;
									}
								}//end of for	
								newnode={
									id:t_id,
									type:t_type,
									x:Number(t_x),
									y:Number(t_y),
									rx:Number(t_rx),
									ry:Number(t_ry),
									color:t_color,
									strokedotted:Number(t_dotted),
									title:t_title,
									fontsize:Number(t_fontsize),
									strokewidth:Number(t_strokewidth),
									selected:t_selected
								};
								newnodes.push(newnode);							
							}//end of if(ss.length>0 ){}
						break;
						case 'edge':
							if( ss.length>0){ 								
								var newedge;
								var t_id='';
								var t_type='';
								var t_node1='';
								var t_node2='';
								var t_handlePx=-1;
								var t_handelPy=-1;
								var t_color=defaultCOLOR;
								var t_dotted='none';
								var t_strokewidth=default_strokeWIDTH;
								var t_label='';
								var t_labelPx=-1;
								var t_labelPy=-1;
								var t_labelFsize =defaultFONTSIZE;
								var t_curve_LR=-1;
								var t_labelInitial = true;
								var t_handleInitial = true;
								var t_IsAutoGenerated = false;

								for(var j=0; j< ss.length; j++){
									var sss =ss[j].split(':'); 
									var attri_name=sss[0]; var l1=attri_name.length; attri_name=attri_name.substr(0,l1);
									var attri_value=sss[1]; var l2=attri_value.length;attri_value=attri_value.substr(0,l2);
									switch(attri_name){
										case 'id': t_id=attri_value;  break;
										case 'type':t_type =attri_value;break;										
										case 'node1':t_node1=attri_value;break;
										case 'node2':t_node2=attri_value;break;
										case 'startnodeid':t_node1=attri_value;break;							
										case 'endnodeid':t_node2=attri_value;break;
										case 'handlePx':t_handlePx=Number(attri_value);break;
										case 'handlePy':t_handlePy=Number(attri_value);break;
										case 'color':t_color=attri_value;break;
										case 'dotted':t_dotted=attri_value;break;
										case 'strokewidth':t_strokewidth=Number(attri_value);break;
										case 'label':t_label=attri_value;break;
										case 'labelPx':t_labelPx=Number(attri_value);break;
										case 'labelPy':t_labelPy=Number(attri_value);break;
										case 'labelFsize':t_labelFsize=Number(attri_value);break;
										case 'curve_LR':t_curve_LR=Number(attri_value);break;
										case 'initial': if (Number(attri_value)==1){t_handleInitial=true;} else if (Number(attri_value)==0)  {t_handleInitial=false;} break;
										case 'handleInitial': if (Number(attri_value)==1){t_handleInitial=true;} else if (Number(attri_value)==0) {t_handleInitial=false;} break;
										case 'labelIntial': if (Number(attri_value)==1){t_labelInitial=true;} else if (Number(attri_value)==0)  {t_labelInitial=false;} break;
										case 'IsAutoGenerated': if (Number(attri_value)==1){t_IsAutoGenerated=true;} else if (Number(attri_value)==0)  {t_IsAutoGenerated=false;} break;
										
									}//end of switch(sss[0]){}
								}//end of for	
								
								if (t_node1 !='' && t_node2!='' && t_type!=''){ 
									newedge = generate_edge(newnodes,t_node1,t_node2,t_type);
									if(t_id!='')newedge.id=t_id;
									if(t_handlePx>=0 && t_handlePy>=0) newedge.handleP={x:t_handlePx, y: t_handlePy};
									newedge.color =t_color;
									newedge.dotted=Number(t_dotted);
									newedge.strokewidth=t_strokewidth;
									newedge.label=t_label;
									newedge.labelFsize=t_labelFsize;
									newedge.labelInitial=t_labelInitial;
									newedge.handleInitial=t_handleInitial;
									newedge.IsAutoGenerated=t_IsAutoGenerated;				
									if(t_curve_LR!=-1) newedge.curve_LR=t_curve_LR;
									newedge = update_bcurve(newnodes,newedge);
									if(t_labelPx>=0 && t_labelPy>=0) { 
										newedge.labelP={x:t_labelPx,y:t_labelPy} ;
									} else {
										newedge.labelP={x:newedge.handleP.x+5,y:newedge.handleP.y-5};
									} 

									newedges.push(newedge);
								}
							}//end of if( ss.length>0){ }
						break;
						case 'note':
							if ( ss.length>0 ) {			
								var newnote;
								var t_x=default_RADIUSH;
								var t_y=default_RADIUSV;
								var t_color=defaultCOLOR;
								var t_text='';
								var t_fontsize=defaultFONTSIZE;
								var t_selected=false;
								for(var j=0; j< ss.length; j++){
									var sss =ss[j].split(':'); 
									var attri_name=sss[0]; var l1=attri_name.length; attri_name=attri_name.substr(0,l1);
									var attri_value=sss[1]; var l2=attri_value.length;attri_value=attri_value.substr(0,l2);
									switch(attri_name){
										case 'x':t_x=attri_value;break;
										case 'y':t_y=attri_value;break;
										case 'color':t_color=attri_value;break;
										case 'text':t_text=attri_value;break;
										case 'fontsize':t_fontsize=attri_value;break;										
									}
								}//end of for	
								newnote={
									x:Number(t_x),
									y:Number(t_y),
									color:t_color,
									text:t_text,
									fontsize:Number(t_fontsize),
									selected:t_selected
								};
								newnotes.push(newnote);
							}
						break;							
						case 'mark' :
							if(ss.length>0 ) { 									
								var t_Nodecurrent_IdNUM=0;
								var t_Edgecurrent_IdNUM=0;
								var t_Elli_current_TitleNUM=0;
								var t_Rec_current_TitleNUM=0;
								var t_h=0;
								var t_w=0;
								for(var j=0; j< ss.length; j++){
									var sss =ss[j].split(':');
									var attri_name=sss[0]; var l1=attri_name.length; attri_name=attri_name.substr(0,l1);
									var attri_value=sss[1]; var l2=attri_value.length;attri_value=attri_value.substr(0,l2);
									switch(attri_name){
										case 'Nodecurrent_IdNUM':  t_Nodecurrent_IdNUM=Number(attri_value);break;
										case 'Edgecurrent_IdNUM': t_Edgecurrent_IdNUM =Number(attri_value);break;
										case 'Elli_current_TitleNUM': t_Elli_current_TitleNUM=Number(attri_value);break;
										case 'Rec_current_TitleNUM':t_Rec_current_TitleNUM=Number(attri_value);break;
										case 'h':t_h=Number(attri_value);break;
										case 'w': t_w=Number(attri_value);break;		
									}
								}//end of for	
								newmarks={
									Nodecurrent_IdNUM:t_Nodecurrent_IdNUM
									,Edgecurrent_IdNUM:t_Edgecurrent_IdNUM
									,Elli_current_TitleNUM:t_Elli_current_TitleNUM
									,Rec_current_TitleNUM:t_Rec_current_TitleNUM
									,h:t_h
									,w:t_w	
								};
							}//end of if(ss.length>0 ) { }	
						break;
						default:;									
					}//end of switch(sta){}
				}//end of else split(',')				
			}//end of switch(s){}
        }//end of for(){}
		var graph={
				nodes:newnodes
				, edges:newedges
				, notes:newnotes
				, marks:newmarks
			};	
		
    return graph;
}

//function： toSVG()
function GraphToSVG(_nodes, _edges, _edges_tangents, _notes){ 
	var svgtxt="";
	var tempw=w;
	var temph=h;
	var tempchartsize = AdjustChartSize(_nodes, _edges, _edges_tangents, _notes);
	tempw=tempchartsize.w;
	temph=tempchartsize.h;
	
	svgtxt += "\n"+"<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'   version='1.1' "
				+ " width= '"+tempw+"px"+"' "+"height='"+temph+"px"+"'>";
	svgtxt += "\n"+ "<defs><marker id='arrowfake' viewBox='0 -5 15 5' refX='15' refY='0' markerWidth='1' markerHeight='1' orient='auto'><polyline points='0,0 15,-5 15,5' stroke-width='1px' stroke='none' fill='none'></polyline></marker></defs>";
	svgtxt += "\n"+"<defs><marker id='endarrow' viewBox='0 -5 15 5' refX='15' refY='0' markerWidth='7' markerHeight='10' orient='auto'><polyline points='0,-5 0,5 15,0 ' stroke-width='1px' stroke='BLACK'  fill='BLACK'></polyline></marker></defs>";
	svgtxt += "\n"+"<defs><marker id='beginarrow' viewBox='0 -5 15 5' refX='15' refY='0' markerWidth='7' markerHeight='10' orient='auto'><polyline points='0,0 15,-5 15,5' stroke-width='1px' stroke='BLACK' fill='BLACK'></polyline></marker></defs>";
	for (var i=0; i<COLORlist.length; i++){
		svgtxt += "\n"+"<defs><marker id='endarrow"+COLORlist[i]+"' viewBox='0 -5 15 5' refX='15' refY='0' markerWidth='7' markerHeight='10' orient='auto'><polyline points='0,-5 0,5 15,0 ' stroke-width='1px' stroke='"+COLORlist[i]+"' fill='"+COLORlist[i]+"' ></polyline></marker></defs>";
		svgtxt += "\n"+"<defs><marker id='beginarrow"+COLORlist[i]+"' viewBox='0 -5 15 5' refX='15' refY='0' markerWidth='7' markerHeight='10' orient='auto'><polyline points='0,0 15,-5 15,5' stroke-width='1px' stroke='"+COLORlist[i]+"' fill='"+COLORlist[i]+"' ></polyline></marker></defs>";	
	}

	//write the _edges one by one:
	svgtxt += "\n" +"<g id ='pathG' class ='path.G'>";
	for (var i=0; i<_edges.length; i++){	
		var tempstrokedotted;
		switch(_edges[i].dotted){
			case 0:tempstrokedotted='none';break;
			case 1:tempstrokedotted='5,5';break;
			default:tempstrokedotted='none';
		}
		var temparrow1;
		var temparrow2;
		svgtxt += "\n" + "<g class='path.Gs'>";

		//the arrows :
		if (_edges[i].type==="uni") {temparrow1="arrowfake";temparrow2="endarrow"+_edges[i].color;} else if (_edges[i].type==="bi"){temparrow1="endarrow"+_edges[i].color;temparrow2="endarrow"+_edges[i].color;}
		var tangentline1 = "M"+  (_edges_tangents[i].interP_out1.x) +","+  (_edges_tangents[i].interP_out1.y)
							+" "+"L"+ (_edges_tangents[i].interP1.x)+","+ (_edges_tangents[i].interP1.y);
		var tangentline2 =  "M"+  (_edges_tangents[i].interP_out2.x) +","+  (_edges_tangents[i].interP_out2.y)
							+" "+"L"+ (_edges_tangents[i].interP2.x)+","+ (_edges_tangents[i].interP2.y);
		svgtxt += "\n"+"<path d='"+tangentline1+"' "
					+ " class='path.Arrow1'" 
					+ " fill='none' "
					+ " stroke= '"+backgroundCOLOR + "' "
					+ " stroke-width='"+_edges[i].strokewidth+"px' " 
					+ " style='marker-end: url(#"+temparrow1+");' "
					+ " ></path>";
		svgtxt += "\n"+"<path d='"+tangentline2+"' "
					+ " class='path.Arrow2'" 
					+ " fill='none' "
					+ " stroke= '"+backgroundCOLOR + "' "
					+ " stroke-width='"+_edges[i].strokewidth+"px' " 
					+ " style='marker-end: url(#"+temparrow2+");' "
					+ " ></path>";
					
		//the path link	
	
		var pathline;
		if(_edges[i].power===2) {
			var startnode=_nodes[matchnodeindex(_nodes,_edges[i].startid)];
			var endnode = _nodes[matchnodeindex(_nodes,_edges[i].endid)];
			var startP={x:startnode.x, y:startnode.y };
			var endP={x:endnode.x,y:endnode.y};
			var cP=_edges[i].cP;
			pathline = "M"+  (startP.x) + " " + (startP.y) + " " + "Q" +  (cP.x)+" " +  (cP.y) + " " +  (endP.x)+" " +  (endP.y) ;
		} else if (_edges[i].power===3){
			var tempP0=_edges[i].P0;
			var tempP1=_edges[i].P1;
			var tempP2=_edges[i].P2;
			var tempP3=_edges[i].P3;
			pathline = "M"+  (tempP0.x) + " " +  (tempP0.y) 
							+ " " + "C" +  (tempP1.x)+" " +  (tempP1.y) 
								+ " " +  (tempP2.x)+" " +  (tempP2.y)
								+" "+  (tempP3.x)+" " +  (tempP3.y);
		}
		
		svgtxt += "\n"+"<path d='"+pathline+"' " 
					+ " class='path.link' " 
					+ " fill='none' " 
					+ " stroke='"+ _edges[i].color+"' "
					+ " stroke-width='"+_edges[i].strokewidth+"px' " 
					+ " stroke-dasharray='"+ tempstrokedotted+"' " 
					+ " ></path>";
		if(svgstatus.IsShowLabels){
		//the label for path
		svgtxt += "\n"+"<text class='text.label' "
					+ " id= '"+"label" + _edges[i].id + "' " 
					+ " text-anchor='middle' " 
					+ " font-size= '"+ _edges[i].labelFsize+"pt"+"' "
					+ " stroke= 'none' "
					+ " fill=' "+ defaultCOLOR+"' "
					+ " x='" +  (_edges[i].labelP.x) + "' "
					+ " y='" +  (_edges[i].labelP.y) +"' "
					+ " >" + _edges[i].label + " </text>";		
		}//end of if (_edges[i].labelshow){}
		
		svgtxt += "\n"+"</g>";
		
	}
	svgtxt += "\n"+"</g>";
	
	//write the _nodes one by one:
	for (var j=0; j< _nodes.length; j++){
		var tempstrokedotted;
		switch(_nodes[j].strokedotted){
			case 0:tempstrokedotted='none';break;
			case 1:tempstrokedotted='5,5';break;
			default:tempstrokedotted='none';
		}
		switch(_nodes[j].type){
			case 'ellipse':
					svgtxt += "\n"+" <g class='ellipse.Gs' id='G"+ _nodes[j].id+"' style='stroke: rgb(0, 0, 0);'>";
					svgtxt += "\n"+" <ellipse class='ellipse.node'"
								+" id='"+_nodes[j].id+"' "
								+ " cx='"+ (_nodes[j].x)+"' "
								+ " cy='"+ (_nodes[j].y)+"' "
								+ " rx='"+ (_nodes[j].rx)+"' "
								+ " ry='"+ (_nodes[j].ry)+"' "
								+ " fill='"+defaultFillCOLOR+"' " 
								+ " stroke='"+_nodes[j].color+"' " 
								+ " stroke-dasharray='"+tempstrokedotted+"' " 
								+ " stroke-width='"+_nodes[j].strokewidth+"px' " 
								+ " ></ellipse>";
					svgtxt +="\n"+"<text class='text.node' "
								+ " text-anchor='middle' "
								+ " font-size='"+ _nodes[j].fontsize+"pt' "
								+ " fill='" + defaultCOLOR+ "' "
								+ " stroke='none' "
								+ " x='"+ (_nodes[j].x)+"' "
								+ " y='"+ (_nodes[j].y+_nodes[j].fontsize/2)+"' "
								+ " >"+ _nodes[j].title+ "</text>";
					svgtxt += "\n"+"</g>";
				break;
			case 'rect':
				svgtxt += "\n"+" <g class='rect.Gs' id='G"+ _nodes[j].id+"' style='stroke: rgb(0, 0, 0);'>";
				svgtxt += "\n"+" <rect class='rect.node' "
							+ " id='"+_nodes[j].id+"' "
							+ " x='"+ (_nodes[j].x-_nodes[j].rx)+"' "
							+ " y='"+ (_nodes[j].y-_nodes[j].ry)+"' "
							+ " width='"+ (_nodes[j].rx*2)+"' "
							+ " height='"+ (_nodes[j].ry*2)+"' "
							+ " fill='"+defaultFillCOLOR+"' " 
							+ " stroke='"+_nodes[j].color+"' " 
							+ " stroke-dasharray='"+tempstrokedotted +"' " 
							+ " stroke-width='"+_nodes[j].strokewidth+"px' " 
							+ " ></rect>";
					svgtxt +="\n"+"<text class='text.node' "
								+ " text-anchor='middle' "
								+ " font-size='"+ _nodes[j].fontsize+"pt' "
								+ " fill='" + defaultCOLOR+ "' "
								+ " stroke='none' "
								+ " x='"+ (_nodes[j].x)+"' "
								+ " y='"+ (_nodes[j].y+_nodes[j].fontsize/2)+"' "
								+ " >"+ _nodes[j].title+ "</text>";
					svgtxt += "\n"+"</g>";
				break;
			
			case 'triangle':
				var points=generatePointsForTriangle(_nodes[j].x,_nodes[j].y,_nodes[j].rx,_nodes[j].ry);
				var polygonStr= (points.p1.x)+","+ (points.p1.y)
								+" "+ (points.p2.x)+","+ (points.p2.y)
								+" "+ (points.p3.x)+","+ (points.p3.y )
								+" "+ (points.p1.x)+","+ (points.p1.y);
				svgtxt += "\n"+" <g class='triangle.Gs' id='G"+ _nodes[j].id+"' style='stroke: rgb(0, 0, 0);'>";
				svgtxt += "\n"+" <polygon class='triangle.node' "
							+ " id='"+_nodes[j].id+"' "						
							+ " points= '"+polygonStr +"' "
							+ " fill='"+defaultFillCOLOR+"' " 
							+ " stroke='"+_nodes[j].color+"' " 
							+ " stroke-dasharray='"+tempstrokedotted +"' " 
							+ " stroke-width='"+_nodes[j].strokewidth+"px' " 
							+ " ></polygon>";
					svgtxt +="\n"+"<text class='text.node' "
								+ " text-anchor='middle' "
								+ " font-size='"+ _nodes[j].fontsize+"pt' "
								+ " fill='" + defaultCOLOR+ "' "
								+ " stroke='none' "
								+ " x='"+ (_nodes[j].x)+"' "
								+ " y='"+ (_nodes[j].y+_nodes[j].fontsize/2)+"' "
								+ " >"+ _nodes[j].title+ "</text>";
					svgtxt += "\n"+"</g>";
				break;
			
		}
	}
	
	//write _notes one by one:
	svgtxt += "\n"+" <g class='note.Gs' id='G._notes'"+" style='stroke: rgb(0, 0, 0);'>";
	for (var j=0; j< _notes.length; j++){

					svgtxt +="\n"+"<text class='text.note' "
								+ " text-anchor='middle' "
								+ " font-size='"+ _notes[j].fontsize+"pt' "
								+ " stroke='none' "
								+ " fill='" + _notes[j].color+ "' "
								+ " x='"+ (_notes[j].x)+"' "
								+ " y='"+ (_notes[j].y)+"' "
								+ " >"+ _notes[j].text+ "</text>";		
	}
	svgtxt += "\n"+"</g>";
	
	svgtxt += "\n"+"</svg>";
	return svgtxt;
}// end of GraphToSVG()
	
function GraphToText1() {
	r = '<p>Start,&nbsp;&nbsp;Type,&nbsp;&nbsp;Path,&nbsp;&nbsp;End,&nbsp;&nbsp;Type,&nbsp;&nbsp;Label</p>';
    for (var i = 0; i < edges.length; i++) {
        var edge = edges[i];
		var startnode =nodes[matchnodeindex(nodes,edge.startid)];
		var endnode = nodes[matchnodeindex(nodes,edge.endid)];
		// maping:
		var nodetype = {};
			nodetype["rect"] = 0;
			nodetype["ellipse"] = 1;
			nodetype["triangle"] = 2;
		var edgetype = {}
			edgetype["uni"] = 1;
			edgetype["bi"] = 0;
			
		r += '<p>' + startnode.type=='triangle' ? '1': startnode.title
			+',&nbsp;&nbsp;'+ nodetype[startnode.type]
			+',&nbsp;&nbsp;'+ edgetype[edge.type]
			+',&nbsp;&nbsp;'+ endnode.title
			+',&nbsp;&nbsp;'+ nodetype[endnode.type]
			+',&nbsp;&nbsp;'+ edge.label
			+'</p>'	;
    }
    return r;
}
